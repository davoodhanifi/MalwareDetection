package javapcapfirst;

import java.io.File;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.math.BigDecimal;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.filechooser.FileFilter;

import org.jnetpcap.Pcap;
import org.jnetpcap.nio.JMemory;
import org.jnetpcap.packet.JFlow;
import org.jnetpcap.packet.JFlowKey;
import org.jnetpcap.packet.JFlowMap;
import org.jnetpcap.packet.JPacket;
import org.jnetpcap.packet.JPacketHandler;
import org.jnetpcap.packet.JScanner;
import org.jnetpcap.packet.PcapPacket;
import org.jnetpcap.protocol.network.Ip4;
import org.jnetpcap.protocol.tcpip.Http;
import org.jnetpcap.protocol.tcpip.Tcp;


public class JavaPcapFirst {

    static Double[] RELSTARTS;
    static String[] SourceIpAddresses, DestIpAddresses;
    static Double[] Durations, SentPacketsPerTime, RecievedPacketsPerTime,
            SentBytesPerTime, RecievedBytesPerTime;
    static Integer[] SourcePorts, DestPorts, NoPacketsAB, NoPacketsBA, NoBytesAB, NoBytesBA,
            SourceIpIntegers, DestIpIntegers;

    
    public static void main(String[] args) {
        String csvFile = "D:/Andriod/DataSet/TRAFFIC/MALWARE/cvsDataSet/Flows.csv";
        String FilePath = "D:/Andriod/DataSet/TRAFFIC/MALWARE/pcapMalwareAndroid";
        FilePath = "D:/Andriod/DataSet/TRAFFIC/MALWARE/pcapMalwareAndroid";
        createCompleteCSV(FilePath, csvFile, "infected");
       
        System.out.println("Compeleted....");


    }//end of main

    /**
     *
     * @param FILENAME آدرس پوشه‌ای که فایلهای ترافیک در آن قرار دارند
     * @param csvFile مسیر فایل نهایی که باید خروجی در آن ریخته شود
     * @param lable برچسبی که نمونه های ترافیکی دارا هستند یعنی Normal یا
     * Infected
     */
    private static void createCompleteCSV(String FILENAME, String csvFile, String lable) {
        int counter = 1;
        File[] files = getFiles(FILENAME);
        System.out.println(files.length);
        //هر خانواده در یک پوشه قرار دارد
        for (File item : files) {
            System.out.println(++counter);
            //نام خانواده‌ای از برنامه‌ها که ترافیک به آن تعلق دارد استخراج میشود
            String family = item.getName();
            System.out.println(item.getAbsolutePath());

            //وارد پوشه‌ی ترافیکهای آن خانواده شده و اطلاعات ترافیکی را واکشی میکنیم
            if (item.isDirectory()) {
                //File[] subFiles = item.listFiles();
                File[] subFiles = item.listFiles(new FilenameFilter() {
                    @Override
                    public boolean accept(File item, String name) {
                        return name.endsWith(".pcap");
                    }
                });

                System.out.println("dir with2 " + subFiles.length);
                for (File subItem : subFiles) {

                    if (subItem.getAbsolutePath().endsWith(".pcap")) {
                        try {
                            String intLabel = "0";
                            if (lable == "normal") {
                                
                                intLabel = "1";
                        }
                         else if (lable == "infected"){
                                intLabel = "2";
                              
                        }
                            //خانواده و برچسب ترافیک را مشخص کرده و حال اطلاعات ترافیکی را واکشی میکنیم    
                            parseFlows2(subItem.getAbsolutePath(), csvFile, intLabel, family);
                            
                        } catch (IOException ex) {
                        	
                            Logger.getLogger(JavaPcapFirst.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                }

            } else if (item.getAbsolutePath().endsWith(".pcap")) {

                try {
                    parseFlows2(item.getAbsolutePath(), csvFile, lable, family);
                } catch (IOException ex) {
                    Logger.getLogger(JavaPcapFirst.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }

    private static void createTrainAndTestCSV(String RootDirectory,
            String trainCsvFile, String testCsvFile, String lable) {
        int counter = 1;
        File[] files = getFiles(RootDirectory);
        System.out.println(files.length);
        //هر خانواده در یک پوشه قرار دارد
        for (File item : files) {
            System.out.println(++counter);
            //نام خانواده‌ای از برنامه‌ها که ترافیک به آن تعلق دارد استخراج میشود
            String family = item.getName();
            System.out.println(item.getAbsolutePath());

            //وارد پوشه‌ی ترافیکهای آن خانواده شده و اطلاعات ترافیکی را واکشی میکنیم
            if (item.isDirectory()) {
                File[] subFiles = item.listFiles(new FilenameFilter() {
                    @Override
                    public boolean accept(File item, String name) {
                        return name.endsWith(".pcap");
                    }
                });
                /**
                 * تعداد فایلهایی که باید در آموزش استفاده شود
                 */
                int trainSampleNumber = (int) Math.ceil(subFiles.length * 0.7);
                //bayad be in tedad az nemooneha dar csv e train ezafe beshe
                System.out.println("dir with1 " + subFiles.length);

                int fileNumber = 1;
                for (File subItem : subFiles) {
                    if (fileNumber < (subFiles.length - trainSampleNumber)) {
                        if (subItem.getAbsolutePath().endsWith(".pcap")) {
                            try {
                                String intLabel = "0";
                                if (lable == "normal") {
                                    
                                    intLabel = "1";
                            }
                             else if (lable == "infected"){
                                    intLabel = "2";
                                  
                            }
                                //خانواده و برچسب ترافیک را مشخص کرده و حال اطلاعات ترافیکی را واکشی میکنیم    
                                parseFlows2(subItem.getAbsolutePath(), testCsvFile, intLabel, family);
                            } catch (IOException ex) {
                                Logger.getLogger(JavaPcapFirst.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }// end of if (subItem.getAbsolutePath().endsWith(".pcap"))


                    } else {
                        if (subItem.getAbsolutePath().endsWith(".pcap")) {
                            try {
                                String intLabel = "0";
                                if (lable == "normal") {
                                    
                                        intLabel = "1";
                                }
                                 else if (lable == "infected"){
                                        intLabel = "2";
                                      
                                }
                                //خانواده و برچسب ترافیک را مشخص کرده و حال اطلاعات ترافیکی را واکشی میکنیم    
                                parseFlows2(subItem.getAbsolutePath(), trainCsvFile, intLabel, family);
                            } catch (IOException ex) {
                                Logger.getLogger(JavaPcapFirst.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }// end of if (subItem.getAbsolutePath().endsWith(".pcap"))
                    }
                    
                    fileNumber++;


                }//end of for (File subItem : subFiles)

            } else if (item.getAbsolutePath().endsWith(".pcap")) {

                try {
                    parseFlows2(item.getAbsolutePath(), trainCsvFile, lable, family);
                } catch (IOException ex) {
                    Logger.getLogger(JavaPcapFirst.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }

    /**
     * لیست فایلها و پوشه‌های یک مسیر را برمیگرداند
     *
     * @param directory
     * @return
     */
    private static File[] getFiles(String directory) {
        File rootDir = new File(directory);
        return rootDir.listFiles();
    }

    /**
     * یک فایل ترافیک را گرفته و جریانهای آن را استخراج کرده واطلاعات را به
     * انتهای یک فایل اضافه و ذخیره میکند
     *
     * @param FILENAME مسیر فایل ترافیک
     * @param csvFile مسیر فایل خروجی
     * @param lable
     * @param family
     * @throws IOException
     */
    public static void parseFlows2(String FILENAME, String csvFile, String lable, String family) throws IOException {
    		
        final StringBuilder errbuf = new StringBuilder();

        final Pcap pcap = Pcap.openOffline(FILENAME, errbuf);
        
        if (pcap == null) {
            System.err.println(errbuf); // Error is stored in errbuf if any  
            return;
        }

        JFlowMap superFlowMap = new JFlowMap();

        pcap.loop(Pcap.LOOP_INFINATE, superFlowMap, null);
        
        Set<JFlowKey> keys = superFlowMap.keySet();
        

        int size = keys.size();
        RELSTARTS = new Double[size];
        SourceIpAddresses = new String[size];
        SourcePorts = new Integer[size];
        DestIpAddresses = new String[size];
        DestPorts = new Integer[size];
        NoPacketsAB = new Integer[size];
        NoPacketsBA = new Integer[size];
        Durations = new Double[size];
        NoBytesAB = new Integer[size];
        NoBytesBA = new Integer[size];
        SourceIpIntegers = new Integer[size];
        DestIpIntegers = new Integer[size];
        SentPacketsPerTime = new Double[size];
        RecievedPacketsPerTime = new Double[size];
        SentBytesPerTime = new Double[size];
        RecievedBytesPerTime = new Double[size];
        int index = 0;

        //اطلاعات جریان های استخراج شده را یکی یکی واکشی میکنیم
        for (JFlowKey key : keys) {
            JFlow flow = superFlowMap.get(key);
            String IpAddressA = "", IpAddressB = "";
            int BytesN = flow.size();
            int PortA, PortB, PacketsN, PacketsABN = 0, PacketsBAN = 0, BytesABN = 0, BytesBAN = 0;
            double duration;
            double RelStart;
            List<JPacket> PacketsAB = flow.getForward();//بسته های ارسالی
            List<JPacket> PacketsBA = flow.getReverse();//بسته های دریافتی
            if (PacketsAB != null) {
                PacketsABN = PacketsAB.size();//تعداد بسته های ارسالی
                //بدست آوردن تعداد بایتهای ارسالی
                for (JPacket item : PacketsAB) {
                    BytesABN += item.size();
                }
            }
            if (PacketsBA != null) {
                PacketsBAN = PacketsBA.size();//تعداد بسته های دریافتی
                //بدست آوردن تعداد بایتهای دریافتی
                for (JPacket item : PacketsBA) {
                    BytesBAN += item.size();
                }
            }

            /**
             * استخراج آدرسهای آی پی و شماره پورتها
             */
            List<JPacket> allPackets = flow.getAll();
            JPacket firstPacket = allPackets.get(0);
            JPacket lastpacket = allPackets.get(allPackets.size() - 1);

            try {
                IpAddressA = getSourceIp(firstPacket);
                IpAddressB = getDestIp(firstPacket);
            } catch (UnknownHostException ex) {
                Logger.getLogger(JavaPcapFirst.class.getName()).log(Level.SEVERE, null, ex);
            }
            PortA = getSourcePort(firstPacket);
            PortB = getDestPort(firstPacket);

            /**
             * استخراج اطلاعات زمانی
             */
            long startTime = firstPacket.getCaptureHeader().timestampInMicros();
            long endTime = lastpacket.getCaptureHeader().timestampInMicros();
            long durationMic = endTime - startTime;

            //برای حذف داده‌های بی فایده و پرت شرط زیر قرار داده شده است
            if (durationMic <= 0 || IpAddressB.equals("26.26.26.26") || PortA == 0) {
                continue;
            }
            duration = durationMic / 1000000.0;
            RelStart = (startTime) / 1000000.0;
            RELSTARTS[index] = RelStart;//new Date(startTime);
            SourceIpAddresses[index] = IpAddressA;
            SourcePorts[index] = PortA;
            DestIpAddresses[index] = IpAddressB;
            DestPorts[index] = PortB;
            NoPacketsAB[index] = PacketsABN;
            NoPacketsBA[index] = PacketsBAN;
            Durations[index] = duration;
            NoBytesAB[index] = BytesABN;
            NoBytesBA[index] = BytesBAN;
            SourceIpIntegers[index] = getIpInteger(IpAddressA);
            DestIpIntegers[index] = getIpInteger(IpAddressB);
            SentPacketsPerTime[index] = PacketsABN / duration;
            RecievedPacketsPerTime[index] = PacketsBAN / duration;
            SentBytesPerTime[index] = BytesABN / duration;
            RecievedBytesPerTime[index] = BytesBAN / duration;
            index++;

//            System.out.println(PacketsABN + "\t," + PacketsBAN
//                    + "\t" + BytesABN + "\t" + BytesBAN + "\t" + duration + "\t" + RelStart
//                    + "\t" + IpAddressA + "\t" + PortA + "\t" + IpAddressB + "\t" + PortB);
        }
        System.out.println("index is " + index);

        /**
         * محاسبه زمان شروع ارتباطات و مرتب سازی داده ها بر حسب زمان شروع ارتباط
         * جریان
         */
        Integer[] indexSymbles = new Integer[RELSTARTS.length];
        for (int i = 0; i < indexSymbles.length; i++) {
            indexSymbles[i] = i;
        }

        //sorting
        for (int i = 0; i < index; i++) {
            for (int j = index - 1; j > i; j--) {
                if (RELSTARTS[j] < (RELSTARTS[j - 1])) {
                    swap(RELSTARTS, j, j - 1);
                    swap(indexSymbles, j, j - 1);
                    swap(NoPacketsAB, j, j - 1);
                    swap(NoPacketsBA, j, j - 1);
                    swap(NoBytesAB, j, j - 1);
                    swap(NoBytesBA, j, j - 1);
                    swap(SourceIpAddresses, j, j - 1);
                    swap(SourcePorts, j, j - 1);
                    swap(DestIpAddresses, j, j - 1);
                    swap(DestPorts, j, j - 1);
                    swap(Durations, j, j - 1);
                    swap(SourceIpIntegers, j, j - 1);
                    swap(DestIpIntegers, j, j - 1);
                    swap(SentPacketsPerTime, j, j - 1);
                    swap(RecievedPacketsPerTime, j, j - 1);
                    swap(SentBytesPerTime, j, j - 1);
                    swap(RecievedBytesPerTime, j, j - 1);

                }
            }
        }
        //نوشتن در فایل csv

        FileWriter writer = new FileWriter(csvFile, true);

//        CSVUtils.writeLine(writer, Arrays.asList("IPAddressA", "PortA", "IPAddressB",
//                "PortB", "PacketsA>B", "BytesA>B", "PacketsA<B", "BytesA<B",
//                "RelStart", "Duration", "Lable", "family"), ';');
//        writer.flush();
        for (int i = 0; i < index; i++) {
            RELSTARTS[i] = RELSTARTS[i] - RELSTARTS[0];
            Double truncatedDouble = new BigDecimal(RELSTARTS[i])
                    .setScale(3, BigDecimal.ROUND_HALF_UP)
                    .doubleValue();
            RELSTARTS[i] = truncatedDouble;
            String flowStr = 
                      lable + ","
                    //+ SourceIpAddresses[i] + ","
                    //+ SourcePorts[i] + ","
                   // + DestIpAddresses[i] + ","
                   // + DestPorts[i] + ","
                    + NoPacketsAB[i] + ","
                    + NoBytesAB[i] + ","
                    + NoPacketsBA[i] + ","
                    + NoBytesBA[i] + ","
                    + RELSTARTS[i] + ","
                    + Durations[i] + ","
                    + SourceIpIntegers[i] + ","
                    + DestIpIntegers[i] + ","
                    + SentPacketsPerTime[i] + ","
                    + SentBytesPerTime[i] + ","
                    + RecievedPacketsPerTime[i] + ","
                    + RecievedBytesPerTime[i];

            String[] arrStr = flowStr.split(",");
            CSVUtils.writeLine(writer, Arrays.asList(arrStr), ',');
            writer.flush();
        }

        writer.close();
        pcap.close();
        System.out.println(index + " rows inserted in file with " + lable + " label.");
    }

    /**
     * دو عنصر یک آرایه را جابجا میکند
     *
     * @param <T>
     * @param array
     * @param i
     * @param j
     */
    private static <T> void swap(final T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    /**
     *
     * @param ipStr رشته مربوط به آدرس آی‌پی را میگیرد
     * @return عدد صحیح معادل آدرس را برمیگرداند
     * @throws UnknownHostException
     */
    public static int getIpInteger(String ipStr) throws UnknownHostException {

        // Parse IP parts into an int array
        int[] ip = new int[4];
        String[] parts = ipStr.split("\\.");

        for (int i = 0; i < 4; i++) {
            ip[i] = Integer.parseInt(parts[i]);
        }

        // Add the above IP parts into an int number representing your IP 
        // in a 32-bit binary form
        int ipNumbers = 0;
        for (int i = 0; i < 4; i++) {
            ipNumbers += ip[i] << (24 - (8 * i));
        }
        return ipNumbers;
    }

    private static JPacket getFirstPacket(String FILENAME) {

        final StringBuilder errbuf = new StringBuilder();
        final Pcap pcap = Pcap.openOffline(FILENAME, errbuf);
        if (pcap == null) {
            System.err.println(errbuf); // Error is stored in errbuf if any  
            return null;
        }
        PcapPacket packet = new PcapPacket(JMemory.POINTER);
        pcap.nextEx(packet);
        pcap.close();
        return packet;

    }

    /**
     * Returns source ip of a packet
     *
     * @param packet
     * @return
     * @throws UnknownHostException
     */
    private static String getSourceIp(JPacket packet) throws UnknownHostException {
        Ip4 ip = new Ip4();
        if (packet.hasHeader(Ip4.ID)) {
            packet.getHeader(ip);
            byte[] sourceIp = ip.source();
            InetAddress inetAddress = InetAddress.getByAddress(sourceIp);
            return inetAddress.getHostAddress();
        }
        return "";
    }

    /**
     * Returns destination ip of a packet
     *
     * @param packet
     * @return
     * @throws UnknownHostException
     */
    private static String getDestIp(JPacket packet) throws UnknownHostException {
        Ip4 ip = new Ip4();
        if (packet.hasHeader(Ip4.ID)) {
            packet.getHeader(ip);
            byte[] destIp = ip.destination();
            InetAddress inetAddress = InetAddress.getByAddress(destIp);
            return inetAddress.getHostAddress();
        }
        return "";
    }

    /**
     * Returns source Tcp port number of a packet
     *
     * @param packet
     * @return
     */
    private static int getSourcePort(JPacket packet) {
        Tcp tcp = new Tcp();
        if (packet.hasHeader(Tcp.ID)) {
            packet.getHeader(tcp);
            int sourcePort = tcp.source();
            return sourcePort;
        }
        return 0;
    }

    /**
     * Returns destination Tcp port number of a packet
     *
     * @param packet
     * @return
     */
    private static int getDestPort(JPacket packet) {
        Tcp tcp = new Tcp();
        if (packet.hasHeader(Tcp.ID)) {
            packet.getHeader(tcp);
            int destPort = tcp.destination();
            return destPort;
        }
        return 0;
    }

    /**
     *
     */
    public static void parseFlows() {
        final String FILENAME = "L:/Project/2014-03-06-android-malware-Notcoampatible.pcap";
        final StringBuilder errbuf = new StringBuilder();

        final Pcap pcap = Pcap.openOffline(FILENAME, errbuf);
        if (pcap == null) {
            System.err.println(errbuf); // Error is stored in errbuf if any  
            return;
        }

        final PcapPacket packet = new PcapPacket(JMemory.POINTER);

        final Map<JFlowKey, JFlow> flows = new HashMap<JFlowKey, JFlow>();

        int i = 0;
        while (pcap.nextEx(packet) == Pcap.NEXT_EX_OK) {
            i++;
            final JFlowKey key = packet.getState().getFlowKey();

            Ip4 ip = new Ip4();
            if (packet.hasHeader(Ip4.ID)) {
                packet.getHeader(ip);

                byte[] source = ip.source();

                InetAddress ipaddr;
                try {
                    ipaddr = InetAddress.getByAddress(source);
                    System.out.println(i + " " + ipaddr.toString());
                } catch (UnknownHostException ex) {
                    Logger.getLogger(JavaPcapFirst.class.getName()).log(Level.SEVERE, null, ex);
                }

                System.out.println();

            }
            Tcp tcp = new Tcp();
            if (packet.hasHeader(Tcp.ID)) {
                packet.getHeader(tcp);
                tcp.source();
            }

            JFlow flow = flows.get(key);
            if (flow == null) {
                flows.put(key, flow = new JFlow(key));
            }

            flow.add(new PcapPacket(packet));
        } //end of while
        System.out.println("The value of i = " + i);

        for (JFlow flow : flows.values()) {
            if (flow.isReversable()) {
                List<JPacket> forward = flow.getForward();
                for (JPacket p : forward) {
                    System.out.printf("%d, ", p.getFrameNumber());
                }
                System.out.println();

                List<JPacket> reverse = flow.getReverse();
                for (JPacket p : reverse) {
                    System.out.printf("%d, ", p.getFrameNumber());
                }
            } else {
                for (JPacket p : flow.getAll()) {
                    System.out.printf("%d, ", p.getFrameNumber());
                }
            }
            System.out.println();
        }

        JFlowMap superFlowMap = new JFlowMap();

        pcap.loop(Pcap.LOOP_INFINATE, superFlowMap, null);

        System.out.printf("superFlowMap::%s%n", superFlowMap);

        pcap.close();

    }

    /**
     * This method is JNetPcap sample code
     */
    public static void JnetSample() {
        /* 
         * Example #1 open offline capture file for reading packets. 
         */
        final String FILENAME = "L:/University/Project/2014-03-06-android-malware-Notcoampatible.pcap";
        final StringBuilder errbuf = new StringBuilder();

        final Pcap pcap = Pcap.openOffline(FILENAME, errbuf);
        if (pcap == null) {
            System.err.println(errbuf); // Error is stored in errbuf if any  
            return;
        }


        /* 
         * We have an opened the capture file now time to read packets. We use a 
         * Pcap.loop function to retrieve 10 packets from the file. We supply an 
         * annonymous handler which will receive packets as they are read from the 
         * offline file by libpcap. We parameterize it with a StringBuilder class. 
         * This allows us to pass in any type of object we need inside the our 
         * dispatch handler. For this example we are passing in the errorbuf object 
         * so we can pass back a string, if we need to. Of course in our example 
         * this is not strictly needed since our anonymous class can access errbuf 
         * object directly from the enclosing main method as that local variable is 
         * marked final allowing anonymous classes access to it. 
         */
        pcap.loop(10, new JPacketHandler<StringBuilder>() {
            /**
             * We purposely define and allocate our working tcp header
             * (accessor) outside the dispatch function and thus the libpcap
             * loop, as this type of object is reusable and it would be a very
             * big waist of time and resources to allocate it per every dispatch
             * of a packet. We mark it final since we do not plan on allocating
             * any other instances of Tcp.
             */
            final Tcp tcp = new Tcp();
            /* 
             * Same thing for our http header 
             */
            final Http http = new Http();

            /**
             * Our custom handler that will receive all the packets libpcap will
             * dispatch to us. This handler is inside a libpcap loop and will
             * receive exactly 10 packets as we specified on the Pcap.loop(10,
             * ...) line above.
             *
             * @param packet a packet from our capture file
             * @param errbuf our custom user parameter which we chose to be a
             * StringBuilder object, but could have chosen anything else we
             * wanted passed into our handler by libpcap
             */
            public void nextPacket(JPacket packet, StringBuilder errbuf) {

                /* 
                 * Here we receive 1 packet at a time from the capture file. We are 
                 * going to check if we have a tcp packet and do something with tcp 
                 * header. We are actually going to do this twice to show 2 different 
                 * ways how we can check if a particular header exists in the packet and 
                 * then get that header (peer header definition instance with memory in 
                 * the packet) in 2 separate steps. 
                 */
                if (packet.hasHeader(Tcp.ID)) {

                    /* 
                     * Now get our tcp header definition (accessor) peered with actual 
                     * memory that holds the tcp header within the packet. 
                     */
                    packet.getHeader(tcp);

                    System.out.printf("tcp.dst_port=%d%n", tcp.destination());
                    System.out.printf("tcp.src_port=%d%n", tcp.source());
                    System.out.printf("tcp.ack=%x%n", tcp.ack());

                }

                /* 
                 * An easier way of checking if header exists and peering with memory 
                 * can be done using a conveniece method JPacket.hasHeader(? extends 
                 * JHeader). This method performs both operations at once returning a 
                 * boolean true or false. True means that header exists in the packet 
                 * and our tcp header difinition object is peered or false if the header 
                 * doesn't exist and no peering was performed. 
                 */
                if (packet.hasHeader(tcp)) {
                    System.out.printf("tcp header::%s%n", tcp.toString());
                }

                /* 
                 * A typical and common approach to getting headers from a packet is to 
                 * chain them as a condition for the if statement. If we need to work 
                 * with both tcp and http headers, for example, we place both of them on 
                 * the command line. 
                 */
                if (packet.hasHeader(tcp) && packet.hasHeader(http)) {
                    /* 
                     * Now we are guarranteed to have both tcp and http header peered. If 
                     * the packet only contained tcp segment even though tcp may have http 
                     * port number, it still won't show up here since headers appear right 
                     * at the beginning of http session. 
                     */

                    System.out.printf("http header::%s%n", http);

                    /* 
                     * jNetPcap keeps track of frame numbers for us. The number is simply 
                     * incremented with every packet scanned. 
                     */
                }

                System.out.printf("frame #%d%n", packet.getFrameNumber());
            }
        }, errbuf);

        /* 
         * Now that we have captured our 10 packets, lets use Pcap.nextEx to get the 
         * next 5 packets. We will also reset the frame number back to 0 just so we 
         * can see how its done. Each scanner keeps track of its own frame numbers, 
         * so we want to get the default one, for this thread, and change it there. 
         */
        JScanner.getThreadLocal().setFrameNumber(0);

        final PcapPacket packet = new PcapPacket(JMemory.POINTER);
        final Tcp tcp = new Tcp();

        for (int i = 0; i < 5; i++) {
            pcap.nextEx(packet);

            if (packet.hasHeader(tcp)) {
                System.out.printf("#%d seq=%08X%n", packet.getFrameNumber(), tcp.seq());
            }
        }

        /* 
         * Each packet scanned, also has a flow key associated with it. The flow key 
         * is generated based on the headers in each packet and stored with packet 
         * state. We can use the flow key to uniquely identify packets belonging to 
         * the same stream of packets between end host systems. We will keep a map 
         * of various flows with packets in it. 
         */
        final Map<JFlowKey, JFlow> flows = new HashMap<JFlowKey, JFlow>();

        for (int i = 0; i < 50; i++) {
            pcap.nextEx(packet);
            final JFlowKey key = packet.getState().getFlowKey();

            /* 
             * A hashmap uses the equals method to determine if a key is already 
             * present in the map or not and to retrieve values. jNetPcap provides us 
             * with a special object called a JFlow which keeps a list of packets part 
             * of that flow. We can add new packets to a flow and later we can get a 
             * list of those packets. So first we check if a flow for a given key 
             * already exists. All packets part of the same flow will have the same 
             * key. 
             */
            JFlow flow = flows.get(key);
            if (flow == null) {
                flows.put(key, flow = new JFlow(key));
            }

            /* 
             * Now that we know for sure we have a flow this packet belongs to, we can 
             * add this packet to this flow. Before we can actuall add a packet to a 
             * queue for later processing, we must first make a copy of the packet to 
             * a new object. We can only process each libpcap packet immediately 
             * before any other calls or nextEx or another iteration of a loop. The 
             * packets are delivered to us without copies so what we are working with 
             * is the data within libpcap buffer. If we want to preserve a packet 
             * beyond this point, we have to make a copy of the packet and its decoded 
             * state and then we can keep the packet around for as long as its needed. 
             * There is a convenience PcapPacket constructor that does a copy of 
             * everything needed for us. 
             */
            flow.add(new PcapPacket(packet));
        }

        /* 
         * Now that we added 50 packets to various flows maintained by the flows 
         * Map, we can now access those flows and the packet within it. The packets 
         * are now grouped into flows. 
         */
        for (JFlow flow : flows.values()) {

            /* 
             * Flows can be bi-directional. That is packets going between host A and B 
             * would be considered in forward-direction, while packets between host B 
             * and A can be considered reserverse direction. Although both forward and 
             * reverse are going in the opposite directions, jnetpcap flows consider 
             * them the same flows. You have 3 types of accessors for retrieving 
             * packets from a flow. JFlow.getForward, JFlow.getReverse or 
             * JFlow.getAll. JFlow.getAll gets a list of packets, no matter which 
             * direction they are going, while the other 2 accessors only get the 
             * packets that are going in the specified direction. 
             */
            if (flow.isReversable()) {
                /* 
                 * We can get directional flow packets, but only if the flow is 
                 * reversable. Not all flows are reversable and this is determined by 
                 * the header types. If a flow is not reversable, flow.getReverse will 
                 * return empty list, which is something we don't want to have to 
                 * process. 
                 */

                List<JPacket> forward = flow.getForward();
                for (JPacket p : forward) {
                    System.out.printf("%d, ", p.getFrameNumber());
                }
                System.out.println();

                List<JPacket> reverse = flow.getReverse();
                for (JPacket p : reverse) {
                    System.out.printf("%d, ", p.getFrameNumber());
                }
            } else {

                /* 
                 * Otherwise we have to get All the packets and there is no 
                 * forward/reverse direction associated with the packets. Here is how we 
                 * can do this a little more compactly. 
                 */
                for (JPacket p : flow.getAll()) {
                    System.out.printf("%d, ", p.getFrameNumber());
                }
            }
            System.out.println();
        }

        /* 
         * We still haven't read all the packets from our offline file. Here is an 
         * easier way to retrieve all the packets while grouping them into flows. 
         * jNetPcap provides a neat little class that does all of the above work for 
         * us. Its called JFlowMap, not only that it implements a JPacketHandler 
         * interface suitable for usage with Pcap.loop or Pcap.dispatch calls and it 
         * will add all packets received into appropriate flows. 
         */
        JFlowMap superFlowMap = new JFlowMap();

        /* 
         * So lets finish this file off, and read the remaining packets into our new 
         * superFlowMap and do a pretty print of all the flows it finds. The 3rd 
         * argument to Pcap.loop is unused so we just set it to null. 
         * Pcap.LOOP_INFINITE flag tells the Pcap.loop method to read all the 
         * packets until the end of file. Since we already read some packets, this 
         * will read remaining packets from the current position in the file until 
         * the end. 
         */
        pcap.loop(Pcap.LOOP_INFINATE, superFlowMap, null);

        System.out.printf("superFlowMap::%s%n", superFlowMap);

        /* 
         * Now we have read the remaining packets and we no longer need to keep the 
         * pcap file open. 
         */
        pcap.close();
    }
}
